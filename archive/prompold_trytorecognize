
def promp_launch(args=args):
    ''' Not useful
    '''
    assert X.ndim==2, "X var is 3D"
    g = list(dict.fromkeys(Y))
    counts = [list(Y).count(g_) for g_ in g]

    paths = Xpalm[:,:,:]

    if True:
        # compute weights
        weights = []
        for i in range(0,len(g)):
            row = []
            for j in range(0,paths.shape[2]):
                d_promp = DiscretePROMP(data=paths[Y==i,:,j])
                d_promp.train()
                d_promp.set_start(data[0][0])
                d_promp.set_goal(data[0][-1])
                if '_mean_W' in args:
                    row.extend(np.array(d_promp._mean_W))
                elif '_sigma_W' in args:
                    row.extend(np.array(d_promp._sigma_W).flatten())
                elif 'diag_sigma_W' in args:
                    row.extend(np.diag(d_promp._sigma_W))
                elif '_W' in args:
                    row.extend(np.array(d_promp._W))
                else: raise Exception("Wrong args")
            weights.append(row)

        # compute weights test
        weights_test = []
        for i in range(0,len(paths)):
            row = []
            for j in range(0, paths.shape[2]):
                d_promp = DiscretePROMP(data=np.vstack([paths[i:i+1,:,j],paths[i:i+1,:,j]]))
                d_promp.train()
                d_promp.set_start(data[0][0])
                d_promp.set_goal(data[0][-1])
                if '_mean_W' in args:
                    row.extend(np.array(d_promp._mean_W))
                elif '_sigma_W' in args:
                    row.extend(np.array(d_promp._sigma_W).flatten())
                elif 'diag_sigma_W' in args:
                    row.extend(np.diag(d_promp._sigma_W))
                elif '_W' in args:
                    row.extend(np.array(d_promp._W))
                else: raise Exception("Wrong args")
            weights_test.append(row)
        weights_test = np.array(weights_test)
        weights = np.array(weights)

        weights.shape
        paths[Y==1].shape
        weights_test.shape
        weights.shape
        len(weights)
        # compare weights with weights_test
        len(weights_test)

        results = []
        for k in range(0,len(weights_test)):
            varwinning = []
            for j in range(0,len(weights_test[0])):
                comparearray = []
                for i in range(0, len(g)):
                    comparearray.append(abs(weights[i,j] - weights_test[k,j]))
                varwinning.append(comparearray)
            dists = []


            varwinning = np.array(varwinning).T
            for row in varwinning:
                vars = (len(varwinning[0])**(1/2))
                dist = LA.norm(np.reshape(np.array(row), (-1,int(vars))), 'fro')
                dists.append(dist)
            results.append(np.argmin(dists))
        results = np.array(results)
        results.shape
        if False:
            d_promp = DiscretePROMP(data=paths[Y==0,:,0])
            d_promp.train()

            for traj in paths[Y==0,:,0]:
                plt.figure("ProMP-Pos")
                plt.plot(traj, 'k', alpha=0.2)


            pos_1, vel_1, acc_1 = d_promp.generate_trajectory(phase_speed=1.,  randomness=1e-1)

            plt.figure("ProMP-Pos")
            plt.xlabel("time - normalized [%]")
            plt.ylabel("x position")
            plt.plot(pos_1, 'r', lw=5)
            plt.savefig(os.path.expanduser("~/Pictures/plot1.png"), format='png')

        name = 'tmp'
        confusion_matrix_pretty_print.plot_confusion_matrix_from_data(Y, results, Gs, annot=True, cmap = 'Oranges', fmt='1.8f', fz=12, lw=1.5, cbar=False, figsize=[5,5], show_null_values=2, pred_val_axis='y', name=name)

        print("Accuracy = {}%".format((Y == results).mean() * 100))
